<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PID Control 8 Zone Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            min-height: 100vh;
            color: #ecf0f1;
            overflow-x: auto;
        }

        .container {
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #ecf0f1;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: #f39c12;
        }

        .header p {
            color: #bdc3c7;
            font-size: 1.1rem;
        }

        .control-panel {
            background: rgba(52, 73, 94, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(149, 165, 166, 0.2);
        }

        .global-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn-start {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .zones-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 20px;
        }

        .zone {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .zone:hover {
            transform: translateY(-5px);
        }

        .zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .zone-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .zone-status {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .status-active {
            background: #4CAF50;
            color: white;
        }

        .status-inactive {
            background: #ccc;
            color: #666;
        }

        .pid-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-group {
            text-align: center;
        }

        .control-group label {
            display: block;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .control-input {
            width: 100%;
            padding: 8px;
            border: 2px solid rgba(149, 165, 166, 0.3);
            border-radius: 8px;
            text-align: center;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
            background: rgba(44, 62, 80, 0.8);
            color: #ecf0f1;
        }

        .control-input:focus {
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .plastic-selection {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.3);
        }

        .plastic-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .plastic-controls {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .plastic-select {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
            font-size: 1rem;
            font-weight: bold;
        }

        .plastic-temp-display {
            background: rgba(255, 255, 255, 0.25);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .plastic-temp-label {
            font-size: 0.8rem;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .plastic-temp-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .pid-info-panel {
            background: rgba(52, 73, 94, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(149, 165, 166, 0.2);
        }

        .pid-info-header {
            text-align: center;
            margin-bottom: 20px;
            color: #f39c12;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .pid-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .pid-info-card {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: #ecf0f1;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border: 1px solid rgba(149, 165, 166, 0.2);
        }

        .pid-info-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #f39c12;
        }

        .pid-info-content {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #bdc3c7;
        }

        .pid-formula {
            background: rgba(243, 156, 18, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #f39c12;
        }

        .ramp-display {
            background: rgba(52, 73, 94, 0.8);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            text-align: center;
            border: 1px solid rgba(149, 165, 166, 0.2);
        }

        .ramp-progress {
            width: 100%;
            height: 12px;
            background: rgba(44, 62, 80, 0.8);
            border-radius: 6px;
            margin: 8px 0;
            overflow: hidden;
            border: 1px solid rgba(149, 165, 166, 0.2);
        }

        .ramp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            border-radius: 6px;
            transition: width 1s ease;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .ramp-status {
            font-size: 0.9rem;
            font-weight: bold;
            color: #f39c12;
        }

        .setpoint-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .setpoint-section label {
            font-weight: bold;
            color: #555;
            min-width: 80px;
        }

        .setpoint-input {
            flex: 1;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .values-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .value-box {
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .value-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }

        .value-number {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
        }

        .chart-container {
            height: 200px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            position: relative;
            overflow: hidden;
        }

        .chart {
            width: 100%;
            height: 100%;
        }

        .error-display {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            border-radius: 8px;
            font-weight: bold;
        }

        .error-low {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .error-medium {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .error-high {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .zone.active {
            animation: pulse 2s infinite;
        }

        .performance-metrics {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .metric-card {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-title {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .ai-controls {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .ai-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: #333;
            font-weight: bold;
        }

        .ai-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-ai {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn-ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .recommendations {
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.85rem;
            border-left: 4px solid #667eea;
        }

        .tuning-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .status-tuning {
            background: #ffc107;
            color: #856404;
        }

        .status-optimized {
            background: #28a745;
            color: white;
        }

        .status-needs-tuning {
            background: #dc3545;
            color: white;
        }

        .analysis-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .analysis-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .analysis-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .analysis-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .ai-insights {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .insight-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .insight-icon {
            font-size: 1.2rem;
        }

        .auto-tune-progress {
            margin-top: 10px;
            text-align: center;
        }

        .trend-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        .trend-improving {
            background: #d4edda;
            color: #155724;
        }

        .trend-stable {
            background: #d1ecf1;
            color: #0c5460;
        }

        .trend-degrading {
            background: #f8d7da;
            color: #721c24;
        }

        .temperature-section {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .temperature-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .temperature-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .temp-control-group {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .temp-label {
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        .temp-input {
            width: 100%;
            padding: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 1rem;
            text-align: center;
        }

        .temp-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .temp-value-box {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .temp-value-label {
            font-size: 0.8rem;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .temp-value-number {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .temp-error-display {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .temp-error-normal {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid rgba(76, 175, 80, 0.6);
        }

        .temp-error-warning {
            background: rgba(255, 193, 7, 0.3);
            border: 2px solid rgba(255, 193, 7, 0.6);
        }

        .temp-error-critical {
            background: rgba(244, 67, 54, 0.3);
            border: 2px solid rgba(244, 67, 54, 0.6);
        }

        .heating-cooling-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .heating-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .cooling-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .indicator-active {
            color: #ffeb3b;
            font-weight: bold;
        }

        .indicator-inactive {
            opacity: 0.5;
        }

        .temp-trend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .trend-arrow {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .trend-up {
            color: #ff5722;
        }

        .trend-down {
            color: #2196f3;
        }

        .trend-stable {
            color: #4caf50;
        }

        .temperature-chart {
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .temp-limits {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }

        .limit-input {
            flex: 1;
            padding: 6px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 0.9rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè≠ Industrial PID Control 8 Zone System</h1>
            <p>‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° PID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏•‡∏¥‡∏ï‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° - Plastic Processing Control</p>
        </div>

        <div class="pid-info-panel">
            <div class="pid-info-header">üìö PID Control Information & Guidelines</div>
            <div class="pid-info-grid">
                <div class="pid-info-card">
                    <div class="pid-info-title">
                        üéõÔ∏è Proportional (Kp)
                    </div>
                    <div class="pid-info-content">
                        <strong>‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà:</strong> ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡∏ï‡∏≤‡∏°‡∏Ç‡∏ô‡∏≤‡∏î Error<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á:</strong> ‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡πÄ‡∏£‡πá‡∏ß ‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ Overshoot<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥:</strong> ‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏ä‡πâ‡∏≤ ‡πÅ‡∏ï‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£<br>
                        <div class="pid-formula">Output = Kp √ó Error</div>
                        <strong>‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:</strong> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 1.0 ‡πÅ‡∏•‡πâ‡∏ß‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á
                    </div>
                </div>

                <div class="pid-info-card">
                    <div class="pid-info-title">
                        ‚à´ Integral (Ki)
                    </div>
                    <div class="pid-info-content">
                        <strong>‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà:</strong> ‡∏Ç‡∏à‡∏±‡∏î Steady State Error<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á:</strong> ‡∏•‡∏î Error ‡πÄ‡∏£‡πá‡∏ß ‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥:</strong> ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£ ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏°‡∏µ Error ‡πÄ‡∏´‡∏•‡∏∑‡∏≠<br>
                        <div class="pid-formula">Output += Ki √ó ‚à´Error dt</div>
                        <strong>‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:</strong> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0.1 ‡πÅ‡∏•‡πâ‡∏ß‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Error ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
                    </div>
                </div>

                <div class="pid-info-card">
                    <div class="pid-info-title">
                        üìê Derivative (Kd)
                    </div>
                    <div class="pid-info-content">
                        <strong>‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà:</strong> ‡∏•‡∏î Overshoot ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á:</strong> ‡∏•‡∏î Overshoot ‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ Noise<br>
                        <strong>‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥:</strong> ‡∏°‡∏µ Overshoot ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ Noise<br>
                        <div class="pid-formula">Output += Kd √ó (dError/dt)</div>
                        <strong>‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:</strong> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0.05 ‡πÅ‡∏•‡πâ‡∏ß‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Overshoot
                    </div>
                </div>

                <div class="pid-info-card">
                    <div class="pid-info-title">
                        üå°Ô∏è Temperature Control Tips
                    </div>
                    <div class="pid-info-content">
                        <strong>‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</strong><br>
                        1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏™‡∏ï‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°<br>
                        2. ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞ Ramp-up ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡πÉ‡∏ô 2-5 ‡∏ô‡∏≤‡∏ó‡∏µ<br>
                        3. ‡πÉ‡∏ä‡πâ AI Auto-tune ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ PID<br>
                        4. ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° Error ‡πÅ‡∏•‡∏∞ Trend<br>
                        <strong>‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢:</strong> Temperature Error < 2¬∞C
                    </div>
                </div>
            </div>
        </div>

        <div class="control-panel">
                            <div class="global-controls">
                <button class="btn btn-start" onclick="startSimulation()">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏•‡∏≠‡∏á</button>
                <button class="btn btn-stop" onclick="stopSimulation()">‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏à‡∏≥‡∏•‡∏≠‡∏á</button>
                <button class="btn btn-reset" onclick="resetSimulation()">üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï</button>
                <button class="btn btn-ai" onclick="autoTuneAllZones()">ü§ñ Auto-Tune ‡∏ó‡∏∏‡∏Å‡πÇ‡∏ã‡∏ô</button>
                <button class="btn btn-ai" onclick="optimizeSystem()">‚ö° ‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</button>
                <div style="margin-left: 20px;">
                    <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏à‡∏≥‡∏•‡∏≠‡∏á: </label>
                    <select id="simulationSpeed" onchange="updateSimulationSpeed()">
                        <option value="50">‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å</option>
                        <option value="100" selected>‡∏õ‡∏Å‡∏ï‡∏¥</option>
                        <option value="200">‡∏ä‡πâ‡∏≤</option>
                        <option value="500">‡∏ä‡πâ‡∏≤‡∏°‡∏≤‡∏Å</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="zones-container" id="zonesContainer">
            <!-- Zones will be generated by JavaScript -->
        </div>

        <div class="analysis-panel">
            <h3 style="text-align: center; margin-bottom: 10px;">üß† AI Analysis & Insights</h3>
            <div class="ai-insights">
                <div class="insight-item">
                    <span class="insight-icon">üéØ</span>
                    <span>‡∏£‡∏∞‡∏ö‡∏ö AI ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡πÇ‡∏ã‡∏ô‡πÅ‡∏ö‡∏ö Real-time</span>
                </div>
                <div class="insight-item">
                    <span class="insight-icon">üìà</span>
                    <span id="systemTrend">‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏£‡∏∞‡∏ö‡∏ö: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</span>
                </div>
                <div class="insight-item">
                    <span class="insight-icon">‚ö°</span>
                    <span id="optimizationSuggestion">‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏∞: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</span>
                </div>
            </div>
            
            <div class="analysis-grid">
                <div class="analysis-card">
                    <div class="analysis-title">
                        üìä Performance Analysis
                    </div>
                    <div class="analysis-content">
                        <div>‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°: <span id="overallPerformance">-</span></div>
                        <div>‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î: <span id="bestZone">-</span></div>
                        <div>‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: <span id="worstZone">-</span></div>
                        <div>‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ Settle: <span id="avgSettleTime">-</span></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="performanceProgress" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <div class="analysis-card">
                    <div class="analysis-title">
                        üî¨ Tuning Recommendations
                    </div>
                    <div class="analysis-content" id="globalRecommendations">
                        <div>‚Ä¢ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏à‡∏≤‡∏Å AI</div>
                        <div>‚Ä¢ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏û‡∏§‡∏ï‡∏¥‡∏Å‡∏£‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏ã‡∏ô</div>
                        <div>‚Ä¢ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤ PID ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</div>
                    </div>
                </div>

                <div class="analysis-card">
                    <div class="analysis-title">
                        üéØ Auto-Tuning Status
                    </div>
                    <div class="analysis-content">
                        <div>‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß: <span id="tunedZones">0/8</span></div>
                        <div>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö: <span id="tuningZones">0</span></div>
                        <div>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: <span id="tuningSuccess">0%</span></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="tuningProgress" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <div class="analysis-card">
                    <div class="analysis-title">
                        üìà System Health
                    </div>
                    <div class="analysis-content">
                        <div>Stability Index: <span id="stabilityIndex">100%</span></div>
                        <div>Response Time: <span id="responseTime">-</span></div>
                        <div>Overshoot: <span id="overshoot">-</span></div>
                        <div>Steady State Error: <span id="steadyStateError">-</span></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="healthProgress" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="performance-metrics">
            <h3 style="text-align: center; margin-bottom: 20px;">üìä Performance Metrics</h3>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-title">‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ RMSE</div>
                    <div class="metric-value" id="avgRMSE">0.00</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</div>
                    <div class="metric-value" id="activeZones">0/8</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≥‡∏•‡∏≠‡∏á</div>
                    <div class="metric-value" id="simulationTime">0s</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">System Stability</div>
                    <div class="metric-value" id="systemStability">100%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥ Error</div>
                    <div class="metric-value" id="avgTempError">0.0¬∞C</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î</div>
                    <div class="metric-value" id="hottestZone">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏¢‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î</div>
                    <div class="metric-value" id="coldestZone">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PIDController {
            constructor(kp = 1.0, ki = 0.1, kd = 0.05) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
                this.integral = 0;
                this.previousError = 0;
                this.lastTime = Date.now();
            }

            update(setpoint, currentValue) {
                const now = Date.now();
                const deltaTime = (now - this.lastTime) / 1000.0;
                const error = setpoint - currentValue;

                this.integral += error * deltaTime;
                const derivative = deltaTime > 0 ? (error - this.previousError) / deltaTime : 0;

                const output = this.kp * error + this.ki * this.integral + this.kd * derivative;

                this.previousError = error;
                this.lastTime = now;

                return output;
            }

            reset() {
                this.integral = 0;
                this.previousError = 0;
                this.lastTime = Date.now();
            }

            setGains(kp, ki, kd) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
            }
        }

        // Plastic materials database with processing temperatures
        const plasticDatabase = {
            'PET': { temp: 270, rampTime: 180, name: 'Polyethylene Terephthalate' },
            'HDPE': { temp: 180, rampTime: 120, name: 'High Density Polyethylene' },
            'PVC': { temp: 200, rampTime: 150, name: 'Polyvinyl Chloride' },
            'LDPE': { temp: 160, rampTime: 100, name: 'Low Density Polyethylene' },
            'PP': { temp: 220, rampTime: 140, name: 'Polypropylene' },
            'PS': { temp: 200, rampTime: 130, name: 'Polystyrene' },
            'ABS': { temp: 240, rampTime: 160, name: 'Acrylonitrile Butadiene Styrene' },
            'PC': { temp: 290, rampTime: 200, name: 'Polycarbonate' },
            'PA': { temp: 280, rampTime: 190, name: 'Polyamide (Nylon)' },
            'POM': { temp: 210, rampTime: 140, name: 'Polyoxymethylene' },
            'PMMA': { temp: 250, rampTime: 170, name: 'Polymethyl Methacrylate' },
            'TPU': { temp: 190, rampTime: 125, name: 'Thermoplastic Polyurethane' },
            'PEEK': { temp: 380, rampTime: 240, name: 'Polyetheretherketone' },
            'PPS': { temp: 320, rampTime: 210, name: 'Polyphenylene Sulfide' },
            'PEI': { temp: 340, rampTime: 220, name: 'Polyetherimide' }
        };

        class AITuner {
            constructor() {
                this.tuningHistory = [];
                this.isLearning = false;
                this.knowledgeBase = {
                    // Based on Ziegler-Nichols and modern optimization techniques
                    temperatureControl: { kp: 1.2, ki: 0.15, kd: 0.08 },
                    pressureControl: { kp: 0.8, ki: 0.12, kd: 0.05 },
                    flowControl: { kp: 1.5, ki: 0.2, kd: 0.1 },
                    levelControl: { kp: 1.0, ki: 0.1, kd: 0.06 }
                };
            }

            analyzePerformance(zone) {
                if (zone.history.length < 20) return null;

                const recentHistory = zone.history.slice(-20);
                const errors = recentHistory.map(h => Math.abs(h.setpoint - h.currentValue));
                const avgError = errors.reduce((a, b) => a + b, 0) / errors.length;
                const maxError = Math.max(...errors);
                const settleTime = this.calculateSettleTime(zone);
                const overshoot = this.calculateOvershoot(zone);
                const steadyStateError = this.calculateSteadyStateError(zone);

                return {
                    avgError,
                    maxError,
                    settleTime,
                    overshoot,
                    steadyStateError,
                    score: this.calculatePerformanceScore(avgError, settleTime, overshoot)
                };
            }

            calculateSettleTime(zone) {
                if (zone.history.length < 10) return 0;
                
                const tolerance = zone.setpoint * 0.02; // 2% tolerance
                const recentHistory = zone.history.slice(-50);
                let settleIndex = -1;

                for (let i = recentHistory.length - 1; i >= 0; i--) {
                    if (Math.abs(recentHistory[i].setpoint - recentHistory[i].currentValue) > tolerance) {
                        settleIndex = i;
                        break;
                    }
                }

                return settleIndex >= 0 ? (recentHistory.length - settleIndex) * 0.1 : 0;
            }

            calculateOvershoot(zone) {
                if (zone.history.length < 5) return 0;
                
                const maxValue = Math.max(...zone.history.map(h => h.currentValue));
                return Math.max(0, ((maxValue - zone.setpoint) / zone.setpoint) * 100);
            }

            calculateSteadyStateError(zone) {
                if (zone.history.length < 10) return 0;
                
                const recentValues = zone.history.slice(-10).map(h => h.currentValue);
                const avgValue = recentValues.reduce((a, b) => a + b, 0) / recentValues.length;
                return Math.abs(zone.setpoint - avgValue);
            }

            calculatePerformanceScore(avgError, settleTime, overshoot) {
                const errorScore = Math.max(0, 100 - avgError * 5);
                const timeScore = Math.max(0, 100 - settleTime * 2);
                const overshootScore = Math.max(0, 100 - overshoot * 2);
                
                return (errorScore * 0.4 + timeScore * 0.3 + overshootScore * 0.3);
            }

            generateRecommendations(zone) {
                const performance = this.analyzePerformance(zone);
                if (!performance) return "‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå";

                let recommendations = [];

                // Analyze current PID values
                const currentKp = zone.pid.kp;
                const currentKi = zone.pid.ki;
                const currentKd = zone.pid.kd;

                if (performance.avgError > 5) {
                    if (performance.settleTime > 10) {
                        recommendations.push("üîÑ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏ä‡πâ‡∏≤ - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Kp ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô");
                    }
                    if (performance.steadyStateError > 2) {
                        recommendations.push("üéØ ‡∏°‡∏µ Steady State Error - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Ki ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î Error");
                    }
                }

                if (performance.overshoot > 15) {
                    recommendations.push("‚ö†Ô∏è ‡∏°‡∏µ Overshoot ‡∏°‡∏≤‡∏Å - ‡∏•‡∏î‡∏Ñ‡πà‡∏≤ Kp ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° Kd");
                }

                if (performance.score > 80) {
                    recommendations.push("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡∏µ‡πÅ‡∏•‡πâ‡∏ß - ‡∏Ñ‡∏á‡∏Ñ‡πà‡∏≤ PID ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô");
                } else if (performance.score > 60) {
                    recommendations.push("‚ö° ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ - ‡πÉ‡∏ä‡πâ Auto-tune ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô");
                } else {
                    recommendations.push("üîß ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏°‡∏≤‡∏Å - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Auto-tune");
                }

                // Add specific tuning suggestions
                const suggestedGains = this.calculateOptimalGains(zone, performance);
                recommendations.push(`üí° ‡∏Ñ‡πà‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: Kp=${suggestedGains.kp.toFixed(2)}, Ki=${suggestedGains.ki.toFixed(2)}, Kd=${suggestedGains.kd.toFixed(2)}`);

                return recommendations.join('<br>');
            }

            calculateOptimalGains(zone, performance) {
                // Advanced tuning algorithm combining multiple methods
                let kp = zone.pid.kp;
                let ki = zone.pid.ki;
                let kd = zone.pid.kd;

                // Ziegler-Nichols inspired adjustments
                if (performance.avgError > 5) {
                    kp *= 1.2; // Increase proportional gain for larger errors
                }
                
                if (performance.steadyStateError > 2) {
                    ki *= 1.3; // Increase integral gain for steady state error
                }
                
                if (performance.overshoot > 10) {
                    kp *= 0.8; // Reduce proportional gain for overshoot
                    kd *= 1.4; // Increase derivative gain for stability
                }

                // Apply bounds and smoothing
                kp = Math.max(0.1, Math.min(5.0, kp));
                ki = Math.max(0.01, Math.min(1.0, ki));
                kd = Math.max(0.001, Math.min(0.5, kd));

                return { kp, ki, kd };
            }

            async autoTuneZone(zoneId) {
                const zone = zones[zoneId - 1];
                const progressElement = document.getElementById(`autoTuneProgress${zoneId}`);
                const progressFill = document.getElementById(`progressFill${zoneId}`);
                const statusElement = document.getElementById(`tuningStatus${zoneId}`);

                progressElement.style.display = 'block';
                statusElement.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á';
                statusElement.className = 'tuning-status status-tuning';

                // Genetic Algorithm simulation for PID tuning
                const generations = 10;
                const populationSize = 20;
                let bestGains = { kp: zone.pid.kp, ki: zone.pid.ki, kd: zone.pid.kd };
                let bestScore = 0;

                for (let gen = 0; gen < generations; gen++) {
                    const population = this.generatePopulation(populationSize, bestGains);
                    
                    for (let individual of population) {
                        const score = await this.evaluateIndividual(zone, individual);
                        if (score > bestScore) {
                            bestScore = score;
                            bestGains = { ...individual };
                        }
                    }

                    const progress = ((gen + 1) / generations) * 100;
                    progressFill.style.width = `${progress}%`;
                    
                    // Small delay for visual effect
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // Apply best gains
                zone.pid.setGains(bestGains.kp, bestGains.ki, bestGains.kd);
                this.updateZonePIDDisplay(zoneId, bestGains);

                progressElement.style.display = 'none';
                statusElement.textContent = '‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß';
                statusElement.className = 'tuning-status status-optimized';

                return bestGains;
            }

            generatePopulation(size, baseGains) {
                const population = [];
                for (let i = 0; i < size; i++) {
                    population.push({
                        kp: baseGains.kp * (0.5 + Math.random()),
                        ki: baseGains.ki * (0.5 + Math.random()),
                        kd: baseGains.kd * (0.5 + Math.random())
                    });
                }
                return population;
            }

            async evaluateIndividual(zone, gains) {
                // Simulate performance with these gains
                const tempPid = new PIDController(gains.kp, gains.ki, gains.kd);
                let totalError = 0;
                let tempValue = zone.currentValue;
                
                for (let i = 0; i < 50; i++) {
                    const output = tempPid.update(zone.setpoint, tempValue);
                    tempValue = tempValue * 0.95 + output * 0.1 + (Math.random() - 0.5) * 0.1;
                    const error = Math.abs(zone.setpoint - tempValue);
                    totalError += error;
                }
                
                return Math.max(0, 100 - totalError / 50);
            }

            updateZonePIDDisplay(zoneId, gains) {
                const zoneElement = document.getElementById(`zone${zoneId}`);
                const inputs = zoneElement.querySelectorAll('.control-input');
                inputs[0].value = gains.kp.toFixed(2);
                inputs[1].value = gains.ki.toFixed(3);
                inputs[2].value = gains.kd.toFixed(3);
            }
        }

        // Global AI Tuner instance
        const aiTuner = new AITuner();

        class Zone {
            constructor(id) {
                this.id = id;
                this.pid = new PIDController();
                this.setpoint = 50;
                this.currentValue = 0;
                this.output = 0;
                this.isActive = false;
                this.history = [];
                this.canvas = null;
                this.ctx = null;
                this.maxHistory = 100;
                this.plant = {
                    value: 0,
                    inertia: 0.95,
                    gain: 0.1,
                    noise: 0.5,
                    disturbance: 0
                };
                this.rmse = 0;
                this.errorHistory = [];
                
                // Temperature control properties
                this.temperature = {
                    setpoint: 25.0,        // Target temperature (¬∞C)
                    actual: 22.0,          // Current temperature (¬∞C)
                    error: 0,              // Temperature error
                    previousActual: 22.0,  // Previous temperature for trend
                    heatingOutput: 0,      // Heating element output (0-100%)
                    coolingOutput: 0,      // Cooling element output (0-100%)
                    isHeating: false,      // Heating status
                    isCooling: false,      // Cooling status
                    minLimit: 10.0,        // Minimum temperature limit
                    maxLimit: 80.0,        // Maximum temperature limit
                    history: [],           // Temperature history for charting
                    ambient: 22.0,         // Ambient temperature
                    thermalMass: 0.92,     // Thermal inertia (0-1)
                    heatLoss: 0.02,        // Heat loss coefficient
                    maxHeatingRate: 5.0,   // Max heating rate (¬∞C/min)
                    maxCoolingRate: 3.0    // Max cooling rate (¬∞C/min)
                };

                // Plastic processing and ramp-up system
                this.plastic = {
                    type: 'PET',                    // Current plastic type
                    processingTemp: 270,            // Processing temperature
                    rampTime: 180,                  // Time to reach temperature (seconds)
                    rampStartTime: null,            // Ramp start timestamp
                    isRamping: false,               // Ramping status
                    rampProgress: 0,                // Ramp progress (0-100%)
                    rampStartTemp: 22.0,            // Starting temperature for ramp
                    targetReached: false,           // Target temperature reached
                    estimatedTimeRemaining: 0       // Estimated time to reach target
                };
            }

            setPlasticType(plasticType) {
                if (plasticDatabase[plasticType]) {
                    this.plastic.type = plasticType;
                    this.plastic.processingTemp = plasticDatabase[plasticType].temp;
                    this.plastic.rampTime = plasticDatabase[plasticType].rampTime;
                    this.temperature.setpoint = this.plastic.processingTemp;
                    
                    // Update display
                    const tempDisplay = document.getElementById(`plasticTemp${this.id}`);
                    if (tempDisplay) {
                        tempDisplay.textContent = `${this.plastic.processingTemp}¬∞C`;
                    }
                    
                    // Reset ramp status
                    this.plastic.isRamping = false;
                    this.plastic.rampProgress = 0;
                    this.plastic.targetReached = false;
                    this.updateRampDisplay();
                }
            }

            startRampUp() {
                if (this.plastic.isRamping || this.plastic.targetReached) return;
                
                this.plastic.isRamping = true;
                this.plastic.rampStartTime = Date.now();
                this.plastic.rampStartTemp = this.temperature.actual;
                this.plastic.rampProgress = 0;
                
                const rampDisplay = document.getElementById(`rampDisplay${this.id}`);
                if (rampDisplay) {
                    rampDisplay.style.display = 'block';
                }
            }

            updateRampUp() {
                if (!this.plastic.isRamping || !this.plastic.rampStartTime) return;

                const elapsed = (Date.now() - this.plastic.rampStartTime) / 1000; // seconds
                this.plastic.rampProgress = Math.min(100, (elapsed / this.plastic.rampTime) * 100);
                
                // Calculate ramp temperature
                const tempRange = this.plastic.processingTemp - this.plastic.rampStartTemp;
                const rampedTemp = this.plastic.rampStartTemp + (tempRange * (this.plastic.rampProgress / 100));
                
                // Apply ramped temperature as base, then add PID control on top
                this.temperature.actual = rampedTemp;
                
                // Calculate estimated time remaining
                this.plastic.estimatedTimeRemaining = Math.max(0, this.plastic.rampTime - elapsed);
                
                this.updateRampDisplay();
                
                // Check if ramp is complete
                if (this.plastic.rampProgress >= 100) {
                    this.plastic.isRamping = false;
                    this.plastic.targetReached = true;
                    
                    const rampStatus = document.querySelector(`#rampDisplay${this.id} .ramp-status`);
                    if (rampStatus) {
                        rampStatus.textContent = '‚úÖ Target Temperature Reached';
                        rampStatus.style.color = '#27ae60';
                    }
                }
            }

            updateRampDisplay() {
                const rampFill = document.getElementById(`rampFill${this.id}`);
                const rampTime = document.getElementById(`rampTime${this.id}`);
                
                if (rampFill) {
                    rampFill.style.width = `${this.plastic.rampProgress}%`;
                }
                
                if (rampTime) {
                    const elapsed = this.plastic.rampStartTime ? 
                        Math.floor((Date.now() - this.plastic.rampStartTime) / 1000) : 0;
                    const remaining = Math.floor(this.plastic.estimatedTimeRemaining);
                    
                    rampTime.textContent = `Time: ${elapsed}s / Estimated: ${this.plastic.rampTime}s (${remaining}s remaining)`;
                }
            }

            updateTemperatureSystem() {
                if (!this.isActive) return;

                // Update ramp-up process first
                this.updateRampUp();

                // Only apply PID control if ramp is complete or not ramping
                if (!this.plastic.isRamping) {
                    // Get PID output for temperature control
                    const tempOutput = this.pid.update(this.temperature.setpoint, this.temperature.actual);
                    
                    // Determine heating/cooling based on PID output
                    if (tempOutput > 0) {
                        this.temperature.heatingOutput = Math.min(100, Math.abs(tempOutput) * 2);
                        this.temperature.coolingOutput = 0;
                        this.temperature.isHeating = this.temperature.heatingOutput > 5;
                        this.temperature.isCooling = false;
                    } else {
                        this.temperature.coolingOutput = Math.min(100, Math.abs(tempOutput) * 2);
                        this.temperature.heatingOutput = 0;
                        this.temperature.isHeating = false;
                        this.temperature.isCooling = this.temperature.coolingOutput > 5;
                    }

                    // Simulate temperature physics only when not ramping
                    this.simulateTemperaturePhysics();
                } else {
                    // During ramp-up, show heating status
                    this.temperature.heatingOutput = this.plastic.rampProgress;
                    this.temperature.coolingOutput = 0;
                    this.temperature.isHeating = true;
                    this.temperature.isCooling = false;
                }
                
                // Calculate temperature error
                this.temperature.error = this.temperature.setpoint - this.temperature.actual;
                
                // Store temperature history
                this.temperature.history.push({
                    setpoint: this.temperature.setpoint,
                    actual: this.temperature.actual,
                    heating: this.temperature.heatingOutput,
                    cooling: this.temperature.coolingOutput,
                    time: Date.now()
                });

                if (this.temperature.history.length > this.maxHistory) {
                    this.temperature.history.shift();
                }

                // Update displays
                this.updateTemperatureDisplay();
                this.drawTemperatureChart();
            }

            simulateTemperaturePhysics() {
                const deltaTime = 0.1; // Simulation time step (seconds)
                
                // Calculate heat input/output rates
                let heatRate = 0;
                
                if (this.temperature.isHeating) {
                    heatRate = (this.temperature.heatingOutput / 100) * this.temperature.maxHeatingRate * deltaTime;
                } else if (this.temperature.isCooling) {
                    heatRate = -(this.temperature.coolingOutput / 100) * this.temperature.maxCoolingRate * deltaTime;
                }
                
                // Heat loss to ambient
                const tempDifference = this.temperature.actual - this.temperature.ambient;
                const heatLoss = tempDifference * this.temperature.heatLoss * deltaTime;
                
                // Apply thermal mass (inertia)
                const newTemp = this.temperature.actual * this.temperature.thermalMass + 
                               (heatRate - heatLoss) * (1 - this.temperature.thermalMass);
                
                // Add realistic noise and disturbances
                const noise = (Math.random() - 0.5) * 0.1; // ¬±0.05¬∞C noise
                const disturbance = Math.sin(Date.now() / 20000) * 0.5; // Slow ambient variation
                
                this.temperature.previousActual = this.temperature.actual;
                this.temperature.actual = newTemp + noise + disturbance;
                
                // Enforce physical limits
                this.temperature.actual = Math.max(this.temperature.minLimit, 
                                                 Math.min(this.temperature.maxLimit, this.temperature.actual));
            }

            updateTemperatureDisplay() {
                const zone = document.getElementById(`zone${this.id}`);
                if (!zone) return;

                // Update temperature values
                const setpointEl = zone.querySelector('.temp-setpoint-value');
                const actualEl = zone.querySelector('.temp-actual-value');
                const errorEl = zone.querySelector('.temp-error-value');
                
                if (setpointEl) setpointEl.textContent = `${this.temperature.setpoint.toFixed(1)}¬∞C`;
                if (actualEl) actualEl.textContent = `${this.temperature.actual.toFixed(1)}¬∞C`;
                if (errorEl) errorEl.textContent = `${Math.abs(this.temperature.error).toFixed(1)}¬∞C`;

                // Update error status
                const errorDisplay = zone.querySelector('.temp-error-display');
                if (errorDisplay) {
                    const absError = Math.abs(this.temperature.error);
                    let errorClass = 'temp-error-normal';
                    let errorText = '‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°';
                    
                    if (absError > 5) {
                        errorClass = 'temp-error-critical';
                        errorText = '‡∏ß‡∏¥‡∏Å‡∏§‡∏ï - ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö';
                    } else if (absError > 2) {
                        errorClass = 'temp-error-warning';
                        errorText = '‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô - ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡πÄ‡∏ö‡∏µ‡∏¢‡∏î‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô';
                    }
                    
                    errorDisplay.className = `temp-error-display ${errorClass}`;
                    errorDisplay.textContent = `Status: ${errorText}`;
                }

                // Update heating/cooling indicators
                const heatingEl = zone.querySelector('.heating-indicator');
                const coolingEl = zone.querySelector('.cooling-indicator');
                
                if (heatingEl) {
                    heatingEl.className = `heating-indicator ${this.temperature.isHeating ? 'indicator-active' : 'indicator-inactive'}`;
                    heatingEl.innerHTML = `üî• Heating ${this.temperature.heatingOutput.toFixed(0)}%`;
                }
                
                if (coolingEl) {
                    coolingEl.className = `cooling-indicator ${this.temperature.isCooling ? 'indicator-active' : 'indicator-inactive'}`;
                    coolingEl.innerHTML = `‚ùÑÔ∏è Cooling ${this.temperature.coolingOutput.toFixed(0)}%`;
                }

                // Update temperature trend
                const trendEl = zone.querySelector('.temp-trend');
                if (trendEl) {
                    const tempChange = this.temperature.actual - this.temperature.previousActual;
                    let trendClass = 'trend-stable';
                    let trendSymbol = '‚Üí';
                    let trendText = '‡∏Ñ‡∏á‡∏ó‡∏µ‡πà';
                    
                    if (tempChange > 0.1) {
                        trendClass = 'trend-up';
                        trendSymbol = '‚Üó';
                        trendText = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô';
                    } else if (tempChange < -0.1) {
                        trendClass = 'trend-down';
                        trendSymbol = '‚Üò';
                        trendText = '‡∏•‡∏î‡∏•‡∏á';
                    }
                    
                    trendEl.innerHTML = `
                        <span class="trend-arrow ${trendClass}">${trendSymbol}</span>
                        <span>${trendText}</span>
                    `;
                }
            }

            drawTemperatureChart() {
                const tempChart = document.getElementById(`tempChart${this.id}`);
                if (!tempChart || this.temperature.history.length < 2) return;

                const ctx = tempChart.getContext('2d');
                const width = tempChart.width;
                const height = tempChart.height;

                ctx.clearRect(0, 0, width, height);

                // Draw background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(255, 126, 95, 0.1)');
                gradient.addColorStop(1, 'rgba(254, 180, 123, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                // Calculate temperature range for scaling
                const temps = this.temperature.history.map(h => h.actual);
                const setpoints = this.temperature.history.map(h => h.setpoint);
                const allTemps = [...temps, ...setpoints];
                const minTemp = Math.min(...allTemps) - 2;
                const maxTemp = Math.max(...allTemps) + 2;
                const tempRange = maxTemp - minTemp;

                // Draw setpoint line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const setpointY = height - ((this.temperature.setpoint - minTemp) / tempRange) * height;
                ctx.moveTo(0, setpointY);
                ctx.lineTo(width, setpointY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw actual temperature line
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                ctx.lineWidth = 3;
                ctx.beginPath();

                this.temperature.history.forEach((point, index) => {
                    const x = (index / (this.temperature.history.length - 1)) * width;
                    const y = height - ((point.actual - minTemp) / tempRange) * height;

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                // Add temperature labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '12px Arial';
                ctx.fillText(`${maxTemp.toFixed(1)}¬∞C`, 5, 15);
                ctx.fillText(`${minTemp.toFixed(1)}¬∞C`, 5, height - 5);
            }

            updatePlant(controlOutput) {
                // Simulate a first-order system with noise and disturbance
                const targetChange = controlOutput * this.plant.gain;
                this.plant.value = this.plant.value * this.plant.inertia + targetChange;
                
                // Add noise
                this.plant.value += (Math.random() - 0.5) * this.plant.noise;
                
                // Add periodic disturbance
                this.plant.disturbance = Math.sin(Date.now() / 10000) * 5;
                this.plant.value += this.plant.disturbance;
                
                // Limit values
                this.plant.value = Math.max(0, Math.min(100, this.plant.value));
                
                return this.plant.value;
            }

            updateDisplay() {
                const zone = document.getElementById(`zone${this.id}`);
                const status = zone.querySelector('.zone-status');
                const currentValueEl = zone.querySelector('.current-value');
                const outputValueEl = zone.querySelector('.output-value');
                const errorValueEl = zone.querySelector('.error-value');
                const errorDisplay = zone.querySelector('.error-display');

                status.textContent = this.isActive ? '‡∏ó‡∏≥‡∏á‡∏≤‡∏ô' : '‡∏´‡∏¢‡∏∏‡∏î';
                status.className = `zone-status ${this.isActive ? 'status-active' : 'status-inactive'}`;

                if (currentValueEl) currentValueEl.textContent = this.currentValue.toFixed(2);
                if (outputValueEl) outputValueEl.textContent = this.output.toFixed(2);
                
                const error = Math.abs(this.setpoint - this.currentValue);
                if (errorValueEl) errorValueEl.textContent = error.toFixed(2);

                if (errorDisplay) {
                    let errorClass = 'error-low';
                    let errorText = '‡∏ï‡πà‡∏≥ - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡∏µ';
                    
                    if (error > 10) {
                        errorClass = 'error-high';
                        errorText = '‡∏™‡∏π‡∏á - ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö PID';
                    } else if (error > 5) {
                        errorClass = 'error-medium';
                        errorText = '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á - ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö';
                    }
                    
                    errorDisplay.className = `error-display ${errorClass}`;
                    errorDisplay.textContent = `Error: ${errorText}`;
                }

                zone.className = `zone ${this.isActive ? 'active' : ''}`;
            }

            drawChart() {
                if (!this.canvas || !this.ctx || this.history.length < 2) return;

                const width = this.canvas.width;
                const height = this.canvas.height;

                this.ctx.clearRect(0, 0, width, height);

                // Draw grid
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = (height / 10) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(width, y);
                    this.ctx.stroke();
                }

                if (this.history.length < 2) return;

                const maxTime = this.history[this.history.length - 1].time;
                const minTime = maxTime - 30000; // Last 30 seconds

                // Draw setpoint line
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                const setpointY = height - (this.setpoint / 100) * height;
                this.ctx.moveTo(0, setpointY);
                this.ctx.lineTo(width, setpointY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Draw current value line
                this.ctx.strokeStyle = '#4ecdc4';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                let firstPoint = true;
                this.history.forEach((point, index) => {
                    const x = (index / (this.history.length - 1)) * width;
                    const y = height - (point.currentValue / 100) * height;

                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();

                // Add labels
                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('Setpoint', 10, 20);
                this.ctx.fillText('Current', 10, 35);
                this.ctx.fillText('100', 5, 15);
                this.ctx.fillText('0', 5, height - 5);
            }

            start() {
                this.isActive = true;
                this.pid.reset();
                
                // Start ramp-up process for temperature
                this.startRampUp();
            }

            stop() {
                this.isActive = false;
            }

            update() {
                if (!this.isActive) return;

                // Update both PID control and temperature system
                const output = this.pid.update(this.setpoint, this.currentValue);
                this.output = output;
                this.currentValue = this.updatePlant(output);

                // Update temperature control system
                this.updateTemperatureSystem();

                // Calculate RMSE
                const error = this.setpoint - this.currentValue;
                this.errorHistory.push(error * error);
                if (this.errorHistory.length > 50) {
                    this.errorHistory.shift();
                }
                this.rmse = Math.sqrt(this.errorHistory.reduce((a, b) => a + b, 0) / this.errorHistory.length);

                // Store history for chart
                this.history.push({
                    setpoint: this.setpoint,
                    currentValue: this.currentValue,
                    output: this.output,
                    time: Date.now()
                });

                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                this.updateDisplay();
                this.drawChart();
            }

            reset() {
                this.isActive = false;
                this.currentValue = 0;
                this.output = 0;
                this.history = [];
                this.errorHistory = [];
                this.rmse = 0;
                this.plant.value = 0;
                this.pid.reset();
                
                // Reset temperature system
                this.temperature.actual = this.temperature.ambient;
                this.temperature.error = 0;
                this.temperature.heatingOutput = 0;
                this.temperature.coolingOutput = 0;
                this.temperature.isHeating = false;
                this.temperature.isCooling = false;
                this.temperature.history = [];
                
                // Reset plastic ramp system
                this.plastic.isRamping = false;
                this.plastic.rampProgress = 0;
                this.plastic.rampStartTime = null;
                this.plastic.targetReached = false;
                this.plastic.estimatedTimeRemaining = 0;
                
                // Hide ramp display
                const rampDisplay = document.getElementById(`rampDisplay${this.id}`);
                if (rampDisplay) {
                    rampDisplay.style.display = 'none';
                }
                
                this.updateDisplay();
                this.updateTemperatureDisplay();
                this.updateRampDisplay();
                
                if (this.canvas && this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                const tempChart = document.getElementById(`tempChart${this.id}`);
                if (tempChart) {
                    const ctx = tempChart.getContext('2d');
                    ctx.clearRect(0, 0, tempChart.width, tempChart.height);
                }
            }
        }

        // Global variables
        let zones = [];
        let simulationRunning = false;
        let simulationInterval = null;
        let simulationSpeed = 100;
        let startTime = null;

        // Initialize 8 zones
        function initializeZones() {
            const container = document.getElementById('zonesContainer');
            
            for (let i = 1; i <= 8; i++) {
                const zone = new Zone(i);
                zones.push(zone);

                const zoneElement = createZoneElement(i);
                container.appendChild(zoneElement);

                // Setup main canvas
                const canvas = document.getElementById(`chart${i}`);
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                zone.canvas = canvas;
                zone.ctx = canvas.getContext('2d');

                // Setup temperature chart canvas
                const tempCanvas = document.getElementById(`tempChart${i}`);
                if (tempCanvas) {
                    tempCanvas.width = tempCanvas.offsetWidth;
                    tempCanvas.height = tempCanvas.offsetHeight;
                }

                // Initialize with default plastic (PET)
                zone.setPlasticType('PET');
            }
        }

        function createZoneElement(zoneId) {
            const zoneDiv = document.createElement('div');
            zoneDiv.className = 'zone';
            zoneDiv.id = `zone${zoneId}`;
            
            zoneDiv.innerHTML = `
                <div class="zone-header">
                    <div class="zone-title">Zone ${zoneId}</div>
                    <div class="zone-status status-inactive">‡∏´‡∏¢‡∏∏‡∏î</div>
                </div>

                <div class="plastic-selection">
                    <div class="plastic-header">
                        üè≠ Plastic Material Selection
                    </div>
                    <div class="plastic-controls">
                        <select class="plastic-select" onchange="selectPlastic(${zoneId}, this.value)">
                            <option value="PET">PET - Polyethylene Terephthalate</option>
                            <option value="HDPE">HDPE - High Density Polyethylene</option>
                            <option value="PVC">PVC - Polyvinyl Chloride</option>
                            <option value="LDPE">LDPE - Low Density Polyethylene</option>
                            <option value="PP">PP - Polypropylene</option>
                            <option value="PS">PS - Polystyrene</option>
                            <option value="ABS">ABS - Acrylonitrile Butadiene Styrene</option>
                            <option value="PC">PC - Polycarbonate</option>
                            <option value="PA">PA - Polyamide (Nylon)</option>
                            <option value="POM">POM - Polyoxymethylene</option>
                            <option value="PMMA">PMMA - Polymethyl Methacrylate</option>
                            <option value="TPU">TPU - Thermoplastic Polyurethane</option>
                            <option value="PEEK">PEEK - Polyetheretherketone</option>
                            <option value="PPS">PPS - Polyphenylene Sulfide</option>
                            <option value="PEI">PEI - Polyetherimide</option>
                        </select>
                        <div class="plastic-temp-display">
                            <div class="plastic-temp-label">Processing Temp</div>
                            <div class="plastic-temp-value" id="plasticTemp${zoneId}">270¬∞C</div>
                        </div>
                    </div>
                    <div class="ramp-display" id="rampDisplay${zoneId}" style="display: none;">
                        <div class="ramp-status">üî• Heating Up to Target Temperature</div>
                        <div class="ramp-progress">
                            <div class="ramp-fill" id="rampFill${zoneId}" style="width: 0%"></div>
                        </div>
                        <div id="rampTime${zoneId}">Time: 0s / Estimated: 180s</div>
                    </div>
                </div>
                
                <div class="pid-controls">
                    <div class="control-group">
                        <label>Kp</label>
                        <input type="number" class="control-input" value="1.0" step="0.1" 
                               onchange="updatePIDGains(${zoneId})">
                    </div>
                    <div class="control-group">
                        <label>Ki</label>
                        <input type="number" class="control-input" value="0.1" step="0.01" 
                               onchange="updatePIDGains(${zoneId})">
                    </div>
                    <div class="control-group">
                        <label>Kd</label>
                        <input type="number" class="control-input" value="0.05" step="0.01" 
                               onchange="updatePIDGains(${zoneId})">
                    </div>
                </div>

                <div class="temperature-section">
                    <div class="temperature-header">
                        üå°Ô∏è Temperature Control System
                    </div>
                    
                    <div class="temperature-controls">
                        <div class="temp-control-group">
                            <label class="temp-label">Temperature Setpoint</label>
                            <input type="number" class="temp-input" value="270.0" step="0.5" min="10" max="400"
                                   onchange="updateTemperatureSetpoint(${zoneId}, this.value)">
                        </div>
                        <div class="temp-control-group">
                            <label class="temp-label">Ambient Temperature</label>
                            <input type="number" class="temp-input" value="22.0" step="0.5" min="10" max="40"
                                   onchange="updateAmbientTemperature(${zoneId}, this.value)">
                        </div>
                    </div>

                    <div class="temp-display">
                        <div class="temp-value-box">
                            <div class="temp-value-label">Set Temperature</div>
                            <div class="temp-value-number temp-setpoint-value">270.0¬∞C</div>
                        </div>
                        <div class="temp-value-box">
                            <div class="temp-value-label">Actual Temperature</div>
                            <div class="temp-value-number temp-actual-value">22.0¬∞C</div>
                        </div>
                        <div class="temp-value-box">
                            <div class="temp-value-label">Temperature Error</div>
                            <div class="temp-value-number temp-error-value">248.0¬∞C</div>
                        </div>
                    </div>

                    <div class="temp-error-display temp-error-normal">
                        Status: ‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
                    </div>

                    <div class="heating-cooling-status">
                        <div class="heating-indicator indicator-inactive">
                            üî• Heating 0%
                        </div>
                        <div class="temp-trend">
                            <span class="trend-arrow trend-stable">‚Üí</span>
                            <span>‡∏Ñ‡∏á‡∏ó‡∏µ‡πà</span>
                        </div>
                        <div class="cooling-indicator indicator-inactive">
                            ‚ùÑÔ∏è Cooling 0%
                        </div>
                    </div>

                    <div class="temperature-chart">
                        <canvas id="tempChart${zoneId}" width="350" height="100"></canvas>
                    </div>

                    <div class="temp-limits">
                        <input type="number" class="limit-input" placeholder="Min ¬∞C" value="10"
                               onchange="updateTemperatureLimits(${zoneId})">
                        <input type="number" class="limit-input" placeholder="Max ¬∞C" value="80"
                               onchange="updateTemperatureLimits(${zoneId})">
                    </div>
                </div>

                <div class="ai-controls">
                    <div class="ai-header">
                        ü§ñ AI Assistant
                        <span class="tuning-status status-needs-tuning" id="tuningStatus${zoneId}">‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á</span>
                    </div>
                    <div class="ai-buttons">
                        <button class="btn-ai" onclick="autoTuneZone(${zoneId})">üéØ Auto-Tune</button>
                        <button class="btn-ai" onclick="getRecommendations(${zoneId})">üí° ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</button>
                        <button class="btn-ai" onclick="analyzeZone(${zoneId})">üìä ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</button>
                    </div>
                    <div class="recommendations" id="recommendations${zoneId}" style="display: none;">
                        <div style="font-weight: bold; margin-bottom: 5px;">üí° AI Recommendations:</div>
                        <div id="recommendationText${zoneId}">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå...</div>
                    </div>
                    <div class="auto-tune-progress" id="autoTuneProgress${zoneId}" style="display: none;">
                        <div>üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á Auto-tuning...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill${zoneId}" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <div class="setpoint-section">
                    <label>Setpoint:</label>
                    <input type="number" class="setpoint-input" value="50" min="0" max="100" 
                           onchange="updateSetpoint(${zoneId}, this.value)">
                    <button class="btn" style="padding: 8px 16px; margin-left: 10px;" 
                            onclick="toggleZone(${zoneId})">‚ö° ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î</button>
                </div>

                <div class="values-display">
                    <div class="value-box">
                        <div class="value-label">Current Value</div>
                        <div class="value-number current-value">0.00</div>
                    </div>
                    <div class="value-box">
                        <div class="value-label">Output</div>
                        <div class="value-number output-value">0.00</div>
                    </div>
                    <div class="value-box">
                        <div class="value-label">Error</div>
                        <div class="value-number error-value">0.00</div>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas class="chart" id="chart${zoneId}"></canvas>
                </div>

                <div class="error-display error-low">Error: ‡∏ï‡πà‡∏≥ - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡∏µ</div>
            `;

            return zoneDiv;
        }

        function updatePIDGains(zoneId) {
            const zone = zones[zoneId - 1];
            const zoneElement = document.getElementById(`zone${zoneId}`);
            const inputs = zoneElement.querySelectorAll('.control-input');
            
            const kp = parseFloat(inputs[0].value);
            const ki = parseFloat(inputs[1].value);
            const kd = parseFloat(inputs[2].value);
            
            zone.pid.setGains(kp, ki, kd);
        }

        function updateSetpoint(zoneId, value) {
            const zone = zones[zoneId - 1];
            zone.setpoint = parseFloat(value);
        }

        function toggleZone(zoneId) {
            const zone = zones[zoneId - 1];
            if (zone.isActive) {
                zone.stop();
            } else {
                zone.start();
            }
        }

        function startSimulation() {
            if (simulationRunning) return;
            
            simulationRunning = true;
            startTime = Date.now();
            
            simulationInterval = setInterval(() => {
                zones.forEach(zone => zone.update());
                updateMetrics();
            }, simulationSpeed);
        }

        function stopSimulation() {
            simulationRunning = false;
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
        }

        function resetSimulation() {
            stopSimulation();
            zones.forEach((zone, index) => {
                zone.reset();
                
                // Reset AI status
                const statusElement = document.getElementById(`tuningStatus${index + 1}`);
                if (statusElement) {
                    statusElement.textContent = '‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á';
                    statusElement.className = 'tuning-status status-needs-tuning';
                }
                
                // Hide recommendations
                const recommendationsDiv = document.getElementById(`recommendations${index + 1}`);
                if (recommendationsDiv) {
                    recommendationsDiv.style.display = 'none';
                }
            });
            
            startTime = null;
            updateMetrics();
            updateGlobalRecommendations();
            
            // Reset AI analysis display
            document.getElementById('overallPerformance').textContent = '-';
            document.getElementById('bestZone').textContent = '-';
            document.getElementById('worstZone').textContent = '-';
            document.getElementById('avgSettleTime').textContent = '-';
            document.getElementById('responseTime').textContent = '-';
            document.getElementById('overshoot').textContent = '-';
            document.getElementById('steadyStateError').textContent = '-';
            document.getElementById('tunedZones').textContent = '0/8';
            document.getElementById('tuningZones').textContent = '0';
            document.getElementById('tuningSuccess').textContent = '0%';
            document.getElementById('stabilityIndex').textContent = '100%';
            document.getElementById('systemTrend').textContent = '‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏£‡∏∞‡∏ö‡∏ö: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...';
            document.getElementById('optimizationSuggestion').textContent = '‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏∞: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥';
            
            // Reset temperature metrics
            document.getElementById('avgTempError').textContent = '0.0¬∞C';
            document.getElementById('hottestZone').textContent = '-';
            document.getElementById('coldestZone').textContent = '-';
            
            // Reset progress bars
            document.getElementById('performanceProgress').style.width = '0%';
            document.getElementById('tuningProgress').style.width = '0%';
            document.getElementById('healthProgress').style.width = '100%';
        }

        function updateSimulationSpeed() {
            const speed = document.getElementById('simulationSpeed').value;
            simulationSpeed = parseInt(speed);
            
            if (simulationRunning) {
                stopSimulation();
                startSimulation();
            }
        }

        function updateMetrics() {
            const avgRMSEEl = document.getElementById('avgRMSE');
            const activeZonesEl = document.getElementById('activeZones');
            const simulationTimeEl = document.getElementById('simulationTime');
            const systemStabilityEl = document.getElementById('systemStability');
            const avgTempErrorEl = document.getElementById('avgTempError');
            const hottestZoneEl = document.getElementById('hottestZone');
            const coldestZoneEl = document.getElementById('coldestZone');

            // Calculate average RMSE
            const activeZones = zones.filter(zone => zone.isActive);
            const avgRMSE = activeZones.length > 0 ? 
                activeZones.reduce((sum, zone) => sum + zone.rmse, 0) / activeZones.length : 0;
            avgRMSEEl.textContent = avgRMSE.toFixed(2);

            // Active zones count
            activeZonesEl.textContent = `${activeZones.length}/8`;

            // Simulation time
            if (startTime) {
                const elapsed = (Date.now() - startTime) / 1000;
                simulationTimeEl.textContent = `${elapsed.toFixed(0)}s`;
            }

            // System stability (based on average error)
            const stability = Math.max(0, Math.min(100, 100 - avgRMSE * 10));
            systemStabilityEl.textContent = `${stability.toFixed(0)}%`;

            // Temperature metrics for active zones
            if (activeZones.length > 0) {
                // Calculate average temperature error
                const avgTempError = activeZones.reduce((sum, zone) => 
                    sum + Math.abs(zone.temperature.error), 0) / activeZones.length;
                avgTempErrorEl.textContent = `${avgTempError.toFixed(1)}¬∞C`;

                // Find hottest and coldest zones
                const hottestZone = activeZones.reduce((hottest, zone) => 
                    zone.temperature.actual > hottest.temperature.actual ? zone : hottest);
                const coldestZone = activeZones.reduce((coldest, zone) => 
                    zone.temperature.actual < coldest.temperature.actual ? zone : coldest);

                hottestZoneEl.textContent = `Zone ${hottestZone.id} (${hottestZone.temperature.actual.toFixed(1)}¬∞C)`;
                coldestZoneEl.textContent = `Zone ${coldestZone.id} (${coldestZone.temperature.actual.toFixed(1)}¬∞C)`;
            } else {
                avgTempErrorEl.textContent = '0.0¬∞C';
                hottestZoneEl.textContent = '-';
                coldestZoneEl.textContent = '-';
            }

            // Update AI analysis if simulation is running
            if (simulationRunning && activeZones.length > 0) {
                updateAIAnalysis();
                updateGlobalRecommendations();
            }
        }

        // Plastic selection function
        function selectPlastic(zoneId, plasticType) {
            const zone = zones[zoneId - 1];
            zone.setPlasticType(plasticType);
            
            // Update temperature input field in temperature section
            const zoneElement = document.getElementById(`zone${zoneId}`);
            const tempInputs = zoneElement.querySelectorAll('.temp-input');
            if (tempInputs.length > 0) {
                tempInputs[0].value = zone.plastic.processingTemp; // First input is setpoint
            }
            
            // Update display immediately
            zone.updateTemperatureDisplay();
        }

        // Temperature control functions
        function updateTemperatureSetpoint(zoneId, value) {
            const zone = zones[zoneId - 1];
            zone.setTemperatureSetpoint(value);
        }

        function updateAmbientTemperature(zoneId, value) {
            const zone = zones[zoneId - 1];
            zone.temperature.ambient = parseFloat(value);
        }

        function updateTemperatureLimits(zoneId) {
            const zone = zones[zoneId - 1];
            const zoneElement = document.getElementById(`zone${zoneId}`);
            const limitInputs = zoneElement.querySelectorAll('.limit-input');
            
            const minTemp = parseFloat(limitInputs[0].value) || 10;
            const maxTemp = parseFloat(limitInputs[1].value) || 80;
            
            if (minTemp >= maxTemp) {
                alert('‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î');
                return;
            }
            
            zone.setTemperatureLimits(minTemp, maxTemp);
        }

        // AI-related functions
        async function autoTuneZone(zoneId) {
            const zone = zones[zoneId - 1];
            if (!zone.isActive) {
                alert('‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏ã‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ Auto-tune');
                return;
            }
            
            await aiTuner.autoTuneZone(zoneId);
            updateMetrics();
        }

        function getRecommendations(zoneId) {
            const zone = zones[zoneId - 1];
            const recommendations = aiTuner.generateRecommendations(zone);
            const recommendationsDiv = document.getElementById(`recommendations${zoneId}`);
            const recommendationsText = document.getElementById(`recommendationText${zoneId}`);
            
            recommendationsText.innerHTML = recommendations;
            recommendationsDiv.style.display = 'block';
        }

        function analyzeZone(zoneId) {
            const zone = zones[zoneId - 1];
            const performance = aiTuner.analyzePerformance(zone);
            
            if (!performance) {
                alert('‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå');
                return;
            }
            
            const analysis = `
                üìä Zone ${zoneId} Analysis:
                ‚Ä¢ Performance Score: ${performance.score.toFixed(1)}/100
                ‚Ä¢ Average Error: ${performance.avgError.toFixed(2)}
                ‚Ä¢ Settle Time: ${performance.settleTime.toFixed(1)}s
                ‚Ä¢ Overshoot: ${performance.overshoot.toFixed(1)}%
                ‚Ä¢ Steady State Error: ${performance.steadyStateError.toFixed(2)}
            `;
            
            alert(analysis);
        }

        async function autoTuneAllZones() {
            const activeZones = zones.filter(zone => zone.isActive);
            if (activeZones.length === 0) {
                alert('‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡πà‡∏≠‡∏ô');
                return;
            }
            
            for (let i = 0; i < zones.length; i++) {
                if (zones[i].isActive) {
                    await aiTuner.autoTuneZone(i + 1);
                    await new Promise(resolve => setTimeout(resolve, 500)); // Delay between zones
                }
            }
            
            updateAIAnalysis();
        }

        function optimizeSystem() {
            const activeZones = zones.filter(zone => zone.isActive);
            if (activeZones.length === 0) {
                alert('‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏ã‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
                return;
            }
            
            // Global optimization strategies
            activeZones.forEach((zone, index) => {
                const performance = aiTuner.analyzePerformance(zone);
                if (performance && performance.score < 70) {
                    const optimalGains = aiTuner.calculateOptimalGains(zone, performance);
                    zone.pid.setGains(optimalGains.kp, optimalGains.ki, optimalGains.kd);
                    aiTuner.updateZonePIDDisplay(zones.indexOf(zone) + 1, optimalGains);
                }
            });
            
            updateAIAnalysis();
            alert('‡∏£‡∏∞‡∏ö‡∏ö‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡πÅ‡∏•‡πâ‡∏ß!');
        }

        function updateAIAnalysis() {
            const activeZones = zones.filter(zone => zone.isActive);
            if (activeZones.length === 0) return;

            // Calculate overall performance
            const performances = activeZones.map(zone => aiTuner.analyzePerformance(zone)).filter(p => p);
            if (performances.length === 0) return;

            const avgPerformance = performances.reduce((sum, p) => sum + p.score, 0) / performances.length;
            const bestZone = performances.reduce((best, current, index) => 
                current.score > best.score ? { ...current, index: activeZones[index].id } : best, 
                { score: 0, index: 1 });
            const worstZone = performances.reduce((worst, current, index) => 
                current.score < worst.score ? { ...current, index: activeZones[index].id } : worst, 
                { score: 100, index: 1 });

            // Update UI elements
            document.getElementById('overallPerformance').textContent = `${avgPerformance.toFixed(1)}%`;
            document.getElementById('bestZone').textContent = `Zone ${bestZone.index}`;
            document.getElementById('worstZone').textContent = `Zone ${worstZone.index}`;
            document.getElementById('performanceProgress').style.width = `${avgPerformance}%`;

            // Update tuning status
            const tunedZones = zones.filter(zone => {
                const status = document.getElementById(`tuningStatus${zone.id}`);
                return status && status.textContent === '‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß';
            }).length;
            
            document.getElementById('tunedZones').textContent = `${tunedZones}/8`;
            document.getElementById('tuningProgress').style.width = `${(tunedZones / 8) * 100}%`;
            document.getElementById('tuningSuccess').textContent = `${((tunedZones / Math.max(1, activeZones.length)) * 100).toFixed(0)}%`;

            // System health metrics
            const avgSettleTime = performances.reduce((sum, p) => sum + p.settleTime, 0) / performances.length;
            const avgOvershoot = performances.reduce((sum, p) => sum + p.overshoot, 0) / performances.length;
            const avgSteadyError = performances.reduce((sum, p) => sum + p.steadyStateError, 0) / performances.length;
            
            document.getElementById('avgSettleTime').textContent = `${avgSettleTime.toFixed(1)}s`;
            document.getElementById('responseTime').textContent = `${avgSettleTime.toFixed(1)}s`;
            document.getElementById('overshoot').textContent = `${avgOvershoot.toFixed(1)}%`;
            document.getElementById('steadyStateError').textContent = `${avgSteadyError.toFixed(2)}`;

            // Stability index
            const stabilityIndex = Math.max(0, 100 - (avgSteadyError * 10 + avgOvershoot));
            document.getElementById('stabilityIndex').textContent = `${stabilityIndex.toFixed(0)}%`;
            document.getElementById('healthProgress').style.width = `${stabilityIndex}%`;

            // System trend analysis
            updateSystemTrend(performances);
            updateOptimizationSuggestions(avgPerformance, worstZone);
        }

        function updateSystemTrend(performances) {
            const trendElement = document.getElementById('systemTrend');
            const avgScore = performances.reduce((sum, p) => sum + p.score, 0) / performances.length;
            
            let trendText = '';
            let trendClass = '';
            
            if (avgScore > 80) {
                trendText = '‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏£‡∏∞‡∏ö‡∏ö: ‡∏î‡∏µ‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏° - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û';
                trendClass = 'trend-improving';
            } else if (avgScore > 60) {
                trendText = '‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏£‡∏∞‡∏ö‡∏ö: ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á - ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°';
                trendClass = 'trend-stable';
            } else {
                trendText = '‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏£‡∏∞‡∏ö‡∏ö: ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Auto-tune';
                trendClass = 'trend-degrading';
            }
            
            trendElement.innerHTML = `${trendText} <span class="trend-indicator ${trendClass}">‚óè</span>`;
        }

        function updateOptimizationSuggestions(avgPerformance, worstZone) {
            const suggestionElement = document.getElementById('optimizationSuggestion');
            let suggestion = '';
            
            if (avgPerformance > 85) {
                suggestion = '‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏∞: ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡∏µ‡πÅ‡∏•‡πâ‡∏ß - ‡∏Ñ‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô';
            } else if (avgPerformance > 70) {
                suggestion = `‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏∞: ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á Zone ${worstZone.index} ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û`;
            } else {
                suggestion = '‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏∞: ‡πÉ‡∏ä‡πâ Auto-tune ‡∏ó‡∏∏‡∏Å‡πÇ‡∏ã‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏∞‡∏ö‡∏ö';
            }
            
            suggestionElement.textContent = suggestion;
        }

        function updateGlobalRecommendations() {
            const activeZones = zones.filter(zone => zone.isActive);
            const recommendationsElement = document.getElementById('globalRecommendations');
            
            if (activeZones.length === 0) {
                recommendationsElement.innerHTML = `
                    <div>‚Ä¢ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏ã‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</div>
                    <div>‚Ä¢ ‡∏£‡∏∞‡∏ö‡∏ö AI ‡∏à‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</div>
                `;
                return;
            }

            const performances = activeZones.map(zone => aiTuner.analyzePerformance(zone)).filter(p => p);
            if (performances.length === 0) {
                recommendationsElement.innerHTML = `
                    <div>‚Ä¢ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå...</div>
                    <div>‚Ä¢ ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ AI ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û</div>
                `;
                return;
            }

            const avgScore = performances.reduce((sum, p) => sum + p.score, 0) / performances.length;
            const problematicZones = performances.filter(p => p.score < 60).length;
            
            let recommendations = [];
            
            if (avgScore > 80) {
                recommendations.push('‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏°‡∏≤‡∏Å - ‡∏Ñ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô');
                recommendations.push('üìä ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏∑‡πà‡∏ô');
            } else if (avgScore > 60) {
                recommendations.push('‚ö° ‡πÉ‡∏ä‡πâ Auto-tune ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û');
                recommendations.push(`üéØ ‡∏°‡∏µ ${problematicZones} ‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á`);
            } else {
                recommendations.push('üîß ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Auto-tune ‡∏ó‡∏∏‡∏Å‡πÇ‡∏ã‡∏ô');
                recommendations.push('üìà ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏≤‡∏Å');
            }
            
            recommendations.push('üí° ‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏° "‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥" ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏ã‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î');
            
            recommendationsElement.innerHTML = recommendations.map(r => `<div>‚Ä¢ ${r}</div>`).join('');
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeZones();
            
            // Set up canvas resize handling
            window.addEventListener('resize', function() {
                zones.forEach(zone => {
                    if (zone.canvas) {
                        zone.canvas.width = zone.canvas.offsetWidth;
                        zone.canvas.height = zone.canvas.offsetHeight;
                    }
                    
                    // Resize temperature chart canvas
                    const tempCanvas = document.getElementById(`tempChart${zone.id}`);
                    if (tempCanvas) {
                        tempCanvas.width = tempCanvas.offsetWidth;
                        tempCanvas.height = tempCanvas.offsetHeight;
                    }
                });
            });
        });
    </script>
</body>
</html>